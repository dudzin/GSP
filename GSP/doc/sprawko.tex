\documentclass[11pt,a4paper]{article}

\usepackage[compact]{titlesec}
\titleformat*{\section}{\Large\bfseries}
\titleformat*{\subsection}{\large\bfseries}
\titleformat*{\subsubsection}{\normalsize\bfseries}
\titlespacing{\section}{-15pt}{*5}{*3}
\titlespacing{\subsection}{0pt}{*3}{*1.5}
\titlespacing{\subsubsection}{8pt}{*2}{*1}
\setlength{\parskip}{0cm}
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{2}
	
% jezyk i czcionki polskie
\usepackage{polski}
\usepackage[utf8x]{inputenc}
% zmiana wygladu naglowkow sekcji
	%\usepackage{sectsty} 
	%\sectionfont{\large}
%ustawienie marginesĂłw
\usepackage{anysize}
\marginsize{3cm}{3cm}{0.5cm}{1cm}
%inne pakiety
\usepackage{graphicx} %grafiki
\usepackage{color}
\usepackage{amsmath} % matematyka
\usepackage{amssymb} % symbole, np. triangleeq
\usepackage{float}
\usepackage{indentfirst}

% listingi
\usepackage{listings}
\definecolor{dkgreen}{rgb}{0,0.39063,0}
\definecolor{gray}{rgb}{0.5,0.5,0.50}
\lstset{ %
%  language=Matlab,                % the language of the code
  basicstyle=\footnotesize,           % the size of the fonts that are used for the code
  numbers=left,                   % where to put the line-numbers
  numberstyle=\tiny\color{gray},  % the style that is used for the line-numbers
                                  % will be numbered
  numbersep=5pt,                  % how far the line-numbers are from the code
  backgroundcolor=\color{white},      % choose the background color. You must add \usepackage{color}
  showspaces=false,               % show spaces adding particular underscores
  frame=single,                   % adds a frame around the code
  rulecolor=\color{black},        % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  tabsize=2,                      % sets default tabsize to 2 spaces
  captionpos=b,                   % sets the caption-position to bottom
  breaklines=true,                % sets automatic line breaking
                                  % also try caption instead of title
  keywordstyle=\color{blue},          % keyword style
  commentstyle=\color{dkgreen},       % comment style
  stringstyle=\color{mauve},         % string literal style
}


\title{ \textbf{Metody eksploracji danych - projekt} \\ \Large Dokumentacja}
\author{Przemysław Barcikowski, Dariusz Dudziński}

\begin{document}
\maketitle
\section{Zadanie}
\subsection{Temat}
\paragraph{} Wyszukiwanie uogólnionych wzorców sekwencyjnych (Generalized Sequential Patterns)
\subsection{Cel projektu}
\paragraph{} Celem niniejszego projektu jest stworzenie aplikacji spełniającej poniższe wymagania:
\begin{itemize}
\item Aplikacja służy do badania sekwencyjnych reguł asocjacyjnych na podstawie notowań giełdowych,
\item Aplikacja przyjmuje pliki z danymi w formacie .csv, gdzie pierwsza kolumna to nazwa serii, druga to data. Kolejne atrybuty będą wykorzystywane do samego wyliczania sekwencji. Są to wartości liczbowe,
\item Aplikacja automatycznie buduje taksonomię na atrybutach liczbowych w postaci
\begin{itemize}
\item zaokrąglenie do pełnej wartości,
\item wartość dodatnia/ujemna.
\end{itemize}
\item Aplikacja operuje z zadanym przez użytkownika parametrami,

% oknem czasowym (sliding window), ograniczeniami czasowymi (min i max różnica między wystąpieniami w serii) i minimalnym wsparciem

\item Aplikacja generuje sekwencyjne reguły asocjacyjne,
\item Aplikacja jest napisana w języku Java.
\end{itemize}
Dodatkowo:
\begin{itemize}
\item Aplikacja powinna zostać przetestowana zarówno pod kątem poprawności, jak i wydajności,
\item należy przeprowadzić eksperymenty mające na celu wyszukanie ciekawych wzorców sekwencyjnych.
\end{itemize}

\section{Rozwiązanie}
\label{sec:rozwiazanie}
\paragraph{} Do rozwiązania wyżej postawionego problemu został wykorzystany algorytm Generalized Sequential Patterns (GSP) \cite{bib:GSP}. Jako dane do testowania oraz eksperymentów wybrano notowania giełdowe indeksu Dow Jones, pobrane ze strony \cite{bib:DowJones}.

\section{Implementacja}

\subsection{Funkcjonalności aplikacji}
\paragraph{} Aplikacja wykonuje algorytm GSP (opisany w \cite{bib:GSP}), czyli wyszukuje wszystkie uogólnione wzorce sekwencyjne w zadanym pliku z danymi, przy zadanych parametrach algorytmu (patrz \ref{subsec:Param}). Jako wynik działania, aplikacja kieruje do standardowego strumienia wyjścia następujące informacje:
\begin{itemize}
\item Raport z wyszukiwania wzorców sekwencyjnych (przykład: Listing \ref{lst:result1}.),
\begin{lstlisting}[caption={Raport z wyszukiwania},label={lst:result1}]
SEQUENCE SEARCH REPORT:

Step: 1
generated candidates :76
candidates rejected by hash tree: 64
confirmed sequences  :12
ver true 12
\end{lstlisting}
\item Podsumowanie wykonania algorytmu (przykład: Listing \ref{lst:result2}.), zawierające:
\begin{itemize}
\item Zadane parametry,
\item Informacje dotyczące samego wykonania algorytmu,
\item Wskaźniki wydajności.
\end{itemize}
\begin{lstlisting}[caption={Podsumowanie},label={lst:result2}]
SUMMARY

Parameters:
file:        testdata/test4.csv
minSupp:     2
minGap:      28
maxGap:      49
timeConstr:  365
widnowSize:  7
useHashTree: true
hierarchy  : false

Execution info:
execTime: 478ms
Pattern Sequence found: 325
Pattern Sequence reduced by hash tree : 91
Longest: 7

Performance indicators:
Ratio [Confirmed Sequences/Generated Candidates]: 0.3722794959908362
Exec time per confirmed sequence: 1.4707692307692308ms
\end{lstlisting}
\item Wyszukane sekwencje (przykład: Listing \ref{lst:result3}.).
\begin{lstlisting}[caption={Wyszukane sekwencje},label={lst:result3}]
RESULT SERIES:

support: 20 : close.sign:1 , 
support: 20 : close_change.sign:1 , 
support: 20 : volume.sign:1 , 
support: 20 : volume_change:0 , 
\end{lstlisting}
\end{itemize}


\subsection{Konfiguracja parametrów programu}
\label{subsec:Param}
\paragraph{} Parametry algorytmu są podawane za pomocą pliku konfiguracyjnego. Użytkownik może regulować następujące parametry algorytmu:
\begin{itemize}
\item wykorzystywanie drzewa hashującego (parametr $useHashTree$, zmienna binarna),
\item wykorzystywanie taksonomii (parametr $useTaxonomies$, zmienna binarna),
\item wielkość okna czasowego (parametr $slidingWindowSize$, zmienna całkowita, podawana w dniach),
\item minimalne wsparcie (parametr $minSupport$, zmienna całkowita, podawana w dniach),
\item minimalny odstęp (parametr $minGap$, zmienna całkowita, podawana w dniach),
\item maksymalny odstęp (parametr $maxGap$, zmienna całkowita, podawana w dniach),
\item ograniczenie czasowe (parametr $timeConstraint$, zmienna całkowita, podawana w dniach),
\item ścieżka do pliku z danymi (parametr $dataFilePath$).
\end{itemize}
Przykładowy plik konfiguracyjny został pokazany na Listingu \ref{lst:config}.
\begin{lstlisting}[caption={Przykładowy plik konfiguracyjny},label={lst:config}]
useHashTree=true
useTaxonomies=true
slidingWindowSize=7
minSupport=2
minGap=28
maxGap=49
timeConstraint=365
dataFilePath=testdata/test4.csv
\end{lstlisting}
\subsection{Zalecany sposób uruchamiania}
Aplikację można uruchomić na kilka sposobów, zalecany to stworzenie wykonywalnego pliku $.jar$ i wywoływanie go w linii poleceń. Możliwe opcje wywoływania:
\begin{itemize}
\item Z domyślnym plikiem konfiguracyjnym, jego nazwa to $config.properties$, musi się on znajdować w tej samej lokacji, co plik wykonywalny (przykład: Listing \ref{lst:call1}.)
\begin{lstlisting}[caption={Wywołanie dla domyślnego pliku konfiguracyjnego},label={lst:call1}]
java -jar programGSP.jar
\end{lstlisting}
\item Z podaniem ścieżki do pliku konfiguracyjnego (przykład: Listing \ref{lst:call2}.)
\begin{lstlisting}[caption={Wywołanie ze specyfikacją pliku konfiguracyjnego},label={lst:call2}]
java -jar programGSP.jar "config.properties_custom"
\end{lstlisting}
\end{itemize}
\paragraph{} W zależności od wielkości pliku z danymi, wynik działania programu może składać się z wielu linii tekstu. Z tego względu zaleca się przekierowanie wyniku programu do pliku tekstowego (przykład: Listing \ref{lst:call3}.)
\begin{lstlisting}[caption={Wywołanie dla domyślnego pliku konfiguracyjnego},label={lst:call3}]
java -jar programGSP.jar "config.properties_custom" > output.txt
\end{lstlisting}
\subsection{Wybrana technologia i wydajność}
\paragraph{} Aplikacja została napisana w języku Java ze względu na łatwość implementacji. Zostało to okupione wydajnością aplikacji, gdyż Java nie należy do najszybszych języków programowania. Świadomie zrezygnowano z poprawy wydajności na rzecz wygody programowania ze względu na to, że aplikacja ma charakter jedynie demonstracyjny, nie została stworzona z myślą o zastosowaniu w biznesie ani badaniach naukowych.

\section{Testy}
\subsection{Jakościowe}
\paragraph{} Poprawność działania aplikacji zostało przetestowane przy pomocy testów jednostkowych, zawartych w klasach $SequencePatternsTest$ oraz $CSVReaderTest$ (zawarte w plikach $.java$ o takich samych nazwach)
\subsection{Wydajnościowe}
\paragraph{} Sprawdzono również wydajność programu, w zależności od wielkości okna czasowego (sliding window) oraz tego, czy zostały wykorzystane drzewo hashujące oraz taksonomia. Testy przeprowadzone dla dwóch plików z danymi: małego oraz dużego (pod względem ilości rekordów).
\paragraph{} Wyniki algorytmu uruchomionego bez użycia taksonomii nie są interesujące, niezależnie od zestawu danych oraz innych parametrów. algorytm znajdował bardzo mało sekwencji, wyniki nie nadawały się do żadnej sensownej interpretacji. Następujące parametry były stałe dla wszystkich testów:
\begin{itemize}
\item $useTaxonomies$ = true,
\item $minSupport$ = 2,
\item $minGap$ = 28,
\item $maxGap$ = 49,
\item $timeConstraint$ = 365.
\end{itemize}
Przyjęto następujące oznaczenia dla wyników przedstawionych w Tabelach \ref{tab:1_1}. \ref{tab:1_2}. \ref{tab:2_1}. oraz \ref{tab:2_2}.:
\begin{itemize}
\item[$sW$ - ]rozmiar okna czasowego (sliding window) w dniach,
\item[$hT$ - ]zmienna binarna oznaczająca, czy zostało wykorzystane drzewo hashujące.
\end{itemize}

\subsubsection{Testy dla pliku 'test4.csv'}
\label{subsec:test}
\paragraph{} Omawiany plik zawiera 10 rekordów. Tabele \ref{tab:1_1}. oraz \ref{tab:1_2}. przedstawiają wyniki testów.

\begin{table}[!hbt]
\caption{Śr. czas potrzebny na wygenerowanie jednej sekwencji [ms]}
\centering
\begin{tabular}{|c|r|r|}
\hline
$sW\backslash hT$	& true	& false	\\[1.2ex]\hline
7					& 14.58	& 14.89	\\[1ex]\hline
14					& 19.27	& 18.51	\\[1ex]\hline
\end{tabular}
\label{tab:1_1}
\end{table}

\begin{table}[!hbt]
\caption{Współczynnik wygenerowanych kandydatów do potwierdzonych sekwencji}
\centering
\begin{tabular}{|c|r|r|}
\hline
$sW\backslash hT$	& true	& false	\\[1.2ex]\hline
7					& 0.400	& 0.400	\\[1ex]\hline
14					& 0.614	& 0.614	\\[1ex]\hline
\end{tabular}
\label{tab:1_2}
\end{table}

\paragraph{}Rzut oka na Tabelę \ref{tab:1_2}. wystarczy aby wywnioskować, że dla okna czasowego o długości dwóch tygodni algorytm pracuje bardziej efektywnie, więcej kandydatów zostaje zaliczonych jako sekwencje. Lecz jak pokazuje Tabela \ref{tab:1_1}. obliczenia przy większym oknie czasowym wymagają większego nakładu czasowego, średni czas wyszukania jednej sekwencji jest dłuższy, niż dla okna czasowego o długości jednego tygodnia. Okazuje się, że fakt wykorzystania drzewa hashującego nie ma znaczącego wpływu na omawiane wyżej wskaźniki.

\subsubsection{Testy dla pliku 'testBIG.csv'}
\paragraph{} Omawiany plik zawiera 751 rekordów. Tabele \ref{tab:2_1}. oraz \ref{tab:2_2}. przedstawiają wyniki testów.

\begin{table}[!hbt]
\caption{Śr. czas potrzebny na wygenerowanie jednej sekwencji [ms]}
\centering
\begin{tabular}{|c|r|r|}
\hline
$sW\backslash hT$	& true	& false	\\[1.2ex]\hline
7					& 103.2	& 120.5	\\[1ex]\hline
14					& 161.5	& 166.7	\\[1ex]\hline
\end{tabular}
\label{tab:2_1}
\end{table}

\begin{table}[!hbt]
\caption{Współczynnik wygenerowanych kandydatów do potwierdzonych sekwencji}
\centering
\begin{tabular}{|c|r|r|}
\hline
$sW\backslash hT$	& true	& false	\\[1.2ex]\hline
7					& 0.107	& 0.107	\\[1ex]\hline
14					& 0.174	& 0.174	\\[1ex]\hline
\end{tabular}
\label{tab:2_2}
\end{table}

\paragraph{}Wnioski z testów przeprowadzonych na większej porcji danych są analogiczne do tych przedstawionych na końcu sekcji \ref{subsec:test}.

\section{Eksperymenty}
\subsection{Cel eksperymentów}
\paragraph{}Celem eksperymentów opisanych w niniejszej sekcji jest wyszukanie wzorców sekwencyjnych, które pomogą przewidywać zmiany cen akcji na giełdzie. Aby sekwencje nadawały się do wnioskowania, muszą mieć możliwie wysokie wsparcie. wnioskowanie nie powinno dotyczyć przedziału większego, niż dwa tygodnie (aby zapewnić wzajemny wpływ poszczególnych wydarzeń). Oczywiście, sekwencje dotyczące wolumenu obrotu i jego zmian powinny być pominięte.
\subsection{Dane}
\paragraph{}Oprogramowanie zostało napisane do badania notowań giełdowych, więc eksperymenty przeprowadzono na takich właśnie danych. Badano notowania indeksu Dow Jones, plik wsadowy zawierał 751 rekordów, dane pozyskano z \cite{bib:DowJones}.
\subsection{Eksperymenty}
\subsubsection{Parametry początkowe}
\paragraph{}Jako punkt wyjścia przyjęto parametry pokazane na Listingu \ref{lst:expParam1}.
\begin{lstlisting}[caption={Parametry początkowe},label={lst:expParam1}]
useHashTree=true
useTaxonomies=true
slidingWindowSize=7
minSupport=10
minGap=28
maxGap=49
timeConstraint=365
dataFilePath=testdata/testBIG.csv
\end{lstlisting}
\paragraph{}Uruchomienie algorytmu dla parametrów przedstawionych na Listingu \ref{lst:expParam1}. dało zdecydowanie za dużo sekwencji, więc te ustawienia zostały potraktowane jako punkt wyjścia do dalszych poszukiwań.
\paragraph{}Wykorzystanie zarówno drzewa hashującego, jak i taksonomii jest sensowne, więc w dalszych eksperymentach te parametry nie będą modyfikowane. Bez zmian pozostaną również ograniczenie czasowe ($timeConstraint$) oraz plik z danymi.

\subsubsection{Modyfikacja min. wsparcia}
\paragraph{}Kolejne eksperymenty zostały wykonane dla kolejnych wartości min. wsparcia, aby znaleźć jak najczęściej występujące sekwencje. Ustawiono kolejno następujące wartości: 15, 25, 30. Najwyższe występujące wsparcie wynosiło właśnie 30, w ostatnim eksperymencie znaleziono 123 sekwencje, z czego 15 nie zawierało krótszych sekwencji dotyczących wolumenu. To niewielka liczba, lecz wciąż zbyt duża.
\subsubsection{Modyfikacja wielkości okna czasowego}
\paragraph{}Następnie ustawiono wielkość okna czasowego na wartości: 5, 3, 2, co oznacza branie pod uwagę przedziału (kolejno) 10 dni, 6 dni oraz 4 dni. zmiana wielkości okna czasowego na 5 poskutkowało zmniejszeniem liczby znalezionych sekwencji do 71, lecz dalsza modyfikacja tego parametru nie przyniosła żadnych efektów, więc pozostano przy wartości 5. Z wyszukanych sekwencji 9 nie zawierało elementów dotyczących wolumenu, a 5 z nich składało się z więcej niż jednego elementu. To liczba odpowiednio mała, aby przystąpić do szczegółowej analizy wyników.
\subsection{Wyniki}
\paragraph{}W wyniku wyżej opisanych eksperymentów otrzymano 5 sekwencji składających się z co najmniej dwóch elementów dotyczących jedynie cen akcji. Listing \ref{lst:resParam}. pokazuje parametry, dla jakich uzyskano ten wynik, a wspomniane sekwencje znajdują się na Listingu \ref{lst:resSeq1}.
\begin{lstlisting}[caption={Parametry ostateczne},label={lst:resParam}]
useHashTree=true
useTaxonomies=true
slidingWindowSize=5
minSupport=30
minGap=28
maxGap=49
timeConstraint=365
dataFilePath=testdata/testBIG.csv
\end{lstlisting}
\newpage
\begin{lstlisting}[caption={Sekwencje wynikowe},label={lst:resSeq1}]
support: 30 : {close.sign:1 , close_change.round:-1 , } ,
support: 30 : {close.sign:1 , close_change.sign:-1 , } ,
support: 30 : {close.sign:1 , close_change.sign:1 , } ,
support: 30 : {close_change.sign:-1 , close_change.round:-1 , } ,
support: 30 : {close.sign:1 , close_change.sign:-1 , close_change.round:-1 }
\end{lstlisting}
\paragraph{}Poniżej przedstawiono najbardziej interesujące zależności, jakie można wywnioskować z sekwencji wymienionych na Listingu \ref{lst:resSeq1}. :
\begin{itemize}
\item Sekwencje oznaczone numerem 2 oraz 3 występują równie często, co oznacza, że równie często cena akcji spada jak i rośnie ($close_change.sign$ oznacza znak zmiany procentowej ceny akcji). Taki wniosek wzięty bez dodatkowych założeń daje do myślenia, ponieważ jest tożsamy ze stwierdzeniem, że na giełdzie równie często się zyskuje, co traci.
\item Sekwencja oznaczona numerem 4 pokazuje, że najczęściej występującą zaokrągloną wielkością straty ($close_change.sign$:-1) jest -1 ($close_change.round$:-1), co oznacza, że jeżeli cena akcji spada, to najczęściej o około jeden punkt procentowy. To pocieszający wniosek, gdyż podpowiada, że nawet jeżeli inwestor traci, to najczęściej niedużo na przestrzeni 10 dni ($slidingwindowSize$=5).
\end{itemize}
\paragraph{}Wyżej opisane zależności spełniają cel założony na początku eksperymentów, gdyż wynikają z nich sensowne wnioski, możliwe do zastosowania w rzeczywistości. Oczywiście, dla wyższej wiarygodności eksperymenty powinny zostać przeprowadzone na większych i bardziej różnorodnych zbiorach danych.

\section{Wnioski}
\paragraph{}Stworzona aplikacja spełnia wszystkie cele założone na początku projektu, działa poprawnie oraz jest wystarczająco wydajna, aby można było ją używać do prostych eksperymentów. Aplikacja w pełni nadaje się do demonstracji działania algorytmu GSP oraz celów dydaktycznych. Jej wydajność można oczywiście znacząco poprawić np. przepisując cały program na język C, lecz wymagało by to odrobinę więcej czasu, niż implementacja tych samych funkcjonalności w języku Java.
\paragraph{}Stworzone oprogramowanie nie nadaje się do zastosowań badawczych ani biznesowych przez zbyt małą wydajność oraz niewielką liczbę funkcjonalności, ale stanowi dobrą podstawę do dalszego rozwoju.

\nocite{*}
\bibliography{bibl}
\bibliographystyle{plain}

\end{document}
